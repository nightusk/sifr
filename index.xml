<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>sifr</title><link>http://nightusk.github.io/sifr/</link><description>Recent content on sifr</description><generator>Hugo -- gohugo.io</generator><language>ja-jp</language><lastBuildDate>Wed, 09 Jun 2021 20:57:44 +0900</lastBuildDate><atom:link href="http://nightusk.github.io/sifr/index.xml" rel="self" type="application/rss+xml"/><item><title>正規表現(Regular Expression)</title><link>http://nightusk.github.io/sifr/posts/regex/</link><pubDate>Wed, 09 Jun 2021 20:57:44 +0900</pubDate><guid>http://nightusk.github.io/sifr/posts/regex/</guid><description>正規表現とは？ 文字列の集合(set)を表す。
ん？意味が分からない。検索で使っているのをよく見かけるんだけど？
そう。検索で使うときには、条件に指定した文字列の集合に含まれる文字列を返している。 この他に正規表現が使われるシーンとしては、入力チェックがある。入力された文字列がチェック用の文字列集合に含まれていなければエラーとする、というものだ。 多分何のことを言っているのかわからないと思うが、今はそれでいい。下の節で詳しく見ていこう。
最小の正規表現 最小の集合といえば何だろう？そう空集合(empty set:Φ)だ。では、正規表現における空集合は何だろう？何もない文字列、つまり文字数0の
である。当然、検索条件に何も指定しないことになるので、検索結果は0件だろう。
その次に小さな文字列の集合 集合の要素(element)がただ１つとなる正規表現を考えてみよう。例えば、&amp;ldquo;R&amp;quot;だけを要素とする正規表現ならば
R となる。 同様に&amp;quot;XYZ&amp;quot;だけを要素とするなら
XYZ となる。 つまり、一度に１つの条件でしか検索できない普通の検索と同じである。
２つの要素をもつ集合 &amp;ldquo;|&amp;ldquo;で区切ると、前後の２要素をもつ集合ができる。例えば
abc|xyz なら&amp;quot;abc&amp;quot;と&amp;quot;xyz&amp;quot;の２要素をもつ集合となる。 プログラミングの経験があれば、OR演算子と同じ記号を使用していることに気付くでしょう。
複数の要素をもつ文字の集合 ここからようやく正規表現らしい記号が登場する。まずは[](bracket)から。 []で囲まれた文字は、その文字を要素とする文字数1の文字の集合となる。例えば
[asd] であれば、&amp;ldquo;a&amp;quot;と&amp;quot;s&amp;quot;と&amp;quot;d&amp;quot;を要素とする3要素の文字集合となる。この条件で検索すれば&amp;quot;a&amp;quot;か&amp;quot;s&amp;quot;か&amp;quot;d&amp;quot;の文字が検索結果となる。 アルファベットの大文字小文字、合わせて52文字を要素とするには？ 愚直に
[abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRTSUVWXYZ] としてもよいが、範囲を表す文字&amp;rdquo;-&amp;ldquo;を試用することでより簡潔に書くことができる。
[a-zA-Z] これら２つの正規表現はまったく同じ集合である。
繰り返す &amp;ldquo;foo&amp;quot;と&amp;quot;fooo&amp;quot;と&amp;quot;foooo&amp;quot;を要素とする集合を作りたいと仮定しましょう。(どんなとき？&amp;ldquo;foo&amp;quot;と&amp;quot;fooo&amp;quot;と&amp;quot;foooo&amp;quot;を検索して、すべて&amp;quot;foo&amp;quot;に置き換えることを想像しましょう。) |記号を使用して
foo|fooo|foooo とすれば、実現できそうですが、きっとfoooooやfooooooも検索したくなります。そのたびに無限に増やしていくのでしょうか。 もっとよい方法があります。
fo{2,} こうすればfooだろうとfoooooooooooooooooだろうと検索できます。
新しい記号が出てきました。{}(curly bracket)は直前の文字を繰り返すために使います。 使い方はo{1,3}のようにし、これは「oが1回以上、3回以下繰り返す文字列」の集合となります。 {}の中の数は省略することができ、その場合、{3}ならちょうど３回繰り返し、{3,}なら３回以上の繰り返し、{,3}なら３回以下の繰り返しになります。
繰り返したいのは文字列なんだけど 前の節で文字を繰り返す集合を学びました。でも繰り返したいのは文字列だということもあるかもしれません。(braとbrabraとbrabrabraのように)
前の節と同じようにやってみましょうか
bra{1,} braが1回以上繰り返される文字列の集合になってほしいところですが、残念ながら、この正規表現ではbrabrabraは要素とならず、代わりにbraaaaaaaaaaaaaが要素になります。 つまり、{}の直前のaだけが繰り返されるのです。
braを繰り返したければ、()(paren)で囲みます。
(bra){1,} これでbraもbrabraもbrabrabraも要素になります。ちょうど数式の中で優先順位を明らかにするために()で囲むのと同じです。
同じように|の前後でも()が使えます。例えば、center(中心)はイギリスではcentreとつづるようですが、
cent(er|re) とすればどちらも要素となり検索できます。
その他の正規表現 実のところ、ここまで見てきたことで正規表現のほとんどすべてである。 だから
()[]{}| さえわかれば、正規表現を理解した、と言っても過言ではない。 (少し足りないところはあるが)
このほかにもいろいろな記法はあるが、それらは上で説明したことを、もっと楽に表すための手段でしかないし、覚えられなかったとしても上の基本的なやり方で代用できる。
よく使うものだけ例で挙げておこう
記法 別の記法 意味 \d [0-9] 数字 \w [a-zA-Z_0-9] アルファベットか数字かアンダーバー(C言語の変数名や関数名に使用できる文字) \s [ \t\r\n] スペース・タブ・改行などの空白文字 .</description></item><item><title>コンパイラ</title><link>http://nightusk.github.io/sifr/posts/compiler/</link><pubDate>Wed, 07 Apr 2021 21:39:23 +0900</pubDate><guid>http://nightusk.github.io/sifr/posts/compiler/</guid><description>前の記事では、
make tmp と実行し、
cc tmp.c -o tmp と表示されて実行プログラムが作成されました。
ここで、makeはビルド自動化ツールで、ccがコンパイラです。
ここではコンパイラが何をしているのか、何ができるのかを見ていきましょう。
#define CONSTANT 10 #define EN 0 #define JA 1 // main関数 int main() { #if LANGUAGE == EN printf(&amp;#34;hello, %d\n&amp;#34;, CONSTANT); #elif LANGUAGE == JA printf(&amp;#34;こんにちは, %d\n&amp;#34;, CONSTANT); #endif int i = 10; } C言語のバージョン C90: 1990年に策定されたC言語の仕様
C99: 1999年に策定されたC言語の仕様
C11: 2011年に策定されたC言語の仕様
組み込み開発では未だにC90がよく使われます。 少しずつ文法に変更が加えられていますが、C99での変更を知っておくとよいでしょう。 代表的なものには
行コメント構文(//)の追加 ブロック先頭以外でのローカル変数の宣言が可能となった などがあります。
コンパイル時に-std=c90のように指定することでバージョンを切り替えることができます。 例えば上のソースコードでは
cc tmp.c -o tmp -std=c90 -pedantic-error でコンパイルすると下記のようにエラーになりますが、</description></item><item><title>C言語(再)入門</title><link>http://nightusk.github.io/sifr/posts/restart-c/</link><pubDate>Mon, 05 Apr 2021 22:25:26 +0900</pubDate><guid>http://nightusk.github.io/sifr/posts/restart-c/</guid><description>インストール C言語のコンパイルに必要なツールをインストールしましょう。
sudo apt install build-essential 最初の(最小の)Cソース 作業用のディレクトリを作成し、Cソースファイルを作成しましょう。
mkdir src cd $_ vim tmp.c main(){} それでは早速このCソースファイルをコンパイルしましょう。
make tmp cc tmp.c -o tmp tmp.c:1:1: warning: return type defaults to ‘int’ [-Wimplicit-int] 1 | main(){} | ^~~~ 警告は出ていますが、コンパイルは成功したようです。実行してみましょう。
./tmp 何もしないプログラムなので、特に何も起きません。
FizzBuzz もう少し意味のあるプログラムを作成しましょう。
下のプログラムは、3で割り切れる数のときには&amp;quot;fizz&amp;quot;、5で割り切れる数のときには&amp;quot;buzz&amp;quot;、 3でも5でも割り切れるときには&amp;quot;fizzbuzz&amp;quot;と表示し、そうでない数の場合はその数をそのまま表示します(が、そのとおりに動きません)。
vim fizzbuzz.c #include &amp;lt;stdio.h&amp;gt; int main() { for (int i = 1; i &amp;lt;= 20; ++i) if (i % 3 == 0) puts(&amp;#34;fizz&amp;#34;); else if (i % 5 == 0) puts(&amp;#34;buzz&amp;#34;); else if (i % 3 == 0 &amp;amp;&amp;amp; i % 5 == 0) puts(&amp;#34;fizzbuzz&amp;#34;); else printf(&amp;#34;%d\n&amp;#34;, i); } コンパイルして動かしてみましょう。</description></item><item><title>Linuxを始めましょう</title><link>http://nightusk.github.io/sifr/posts/getting-started-linux/</link><pubDate>Sat, 03 Apr 2021 01:38:49 +0900</pubDate><guid>http://nightusk.github.io/sifr/posts/getting-started-linux/</guid><description>インストール Windowsを削除してインストールしたり、Windowsとデュアルブートしたりもできますが、 失敗すると大切なデータが消えることがあります。
ここでは最も簡単でリスクがないWSLを使用することにします。 下記ページのManual installation Stepsに従ってWSL2をインストールしてください。
https://docs.microsoft.com/en-us/windows/wsl/install-win10 distributionはUbuntu 20.04を選択します。
インストールできたらWindowsスタートメニューからUbuntu 20.04 LTSを起動してください。
テキストエディタに慣れましょう Linuxでよく使用するテキストエディタは特殊な操作をするものが多いです。 Vim, Emacs, nanoなどがよく使用されますが、ここではチュートリアルが充実しているVimを使用します。 下記コマンドを実行しチュートリアルに従ってください。
vimtutor command not foundと表示される場合は、コマンドを間違えているか、Vimがインストールされていないです。 たいていの場合Vimはインストールされていると思いますが、インストールするときは下記コマンドを実行してください。
sudo apt install vim</description></item></channel></rss>